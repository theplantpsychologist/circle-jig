<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Circle Jig</title>
    <!---<link rel="stylesheet" href="main.css">--->

</head>
<body>
    <h2>Circle Jig</h2>
    <p>Instructions</p>
    <canvas id = "square" width = 500 height = 500>    </canvas>
    <script src="paper-core.js"></script>
    <script src="app2.js"></script>
    <script type="text/javascript" data-paper-ignore = "true">
        paper.setup(document.getElementById("square"));
/*
        point1 = new paper.Point(50,50);
        point2 = new paper.Point(200,450);
        point3 = new paper.Point(450,100);
        path1 = new paper.Path.Arc(point1,point2,point3);
        var riverStyle = {
            strokeColor: "#A8F5FB",
            //strokeJoin: "round"
        }
        path1.style = riverStyle;
        path1.strokeWidth = 20
*/

        circles = []; //the flaps drawn
        lines = []; //the paths drawn
        flaps = []; //an initial empty, once you extract from .tmd5, it will be replaced
        rivers = [];
        paths = []
        function drawBorder(){
            border = new paper.Path.Rectangle(0,0,square.width/1.2,square.height/1.2);
            border.strokeColor = 'black';
            border.strokeWidth = 3;
            return border
        }
        drawBorder();
        function calculateRivers(){
            //current problems: 
            //the thing patched up with a try catch
            //color scheme
            for(var i=0; i<rivers.length;i++){
                var tempCircles = []
                //surrounded flaps: all the flaps inside a river, including inside subrivers. 
                //the radius of the outer path around the flap will be the distance from inner to the flap + r
                for(var j=0; j<rivers[i].surroundedFlaps.length; j++){

                    tempCircles.push(new paper.Path.Circle({
                        center: new paper.Point(
                            rivers[i].surroundedFlaps[j].x *square.width/1.2,
                            rivers[i].surroundedFlaps[j].y *square.width/1.2 *-1 + square.height/1.2),
                        //radius: (rivers[i].surroundedFlaps[j].r + rivers[i].r) *square.width/1.2
                        radius: (findTreeDistance(rivers[i].surroundedFlaps[j],rivers[i].innerNode) + rivers[i].r) *square.width/1.2
                    }))
                }//find all the circles in the outer path
                //==================
                var intersections = [] //intersections between two outer path arcs
                var subtractions = [] //quadrilaterals: the centers of the two circles and their intersections
                for(var j=0; j<rivers[i].surroundedFlaps.length; j++){
                    for(var k=j+1;k<rivers[i].surroundedFlaps.length;k++){//nested loop to find all pairs
                        var intersection = tempCircles[j].getIntersections(tempCircles[k])
                        if(intersection.length != 2){
                            continue
                        }
                        var intersection1 = true;
                        var intersection2 = true;
                        
                        /////////
                        chunk1 = new paper.Path.Circle({
                            center: intersection[0].point,
                            radius: rivers[i].r*square.width/1.2
                        })
                        chunk2 = new paper.Path.Circle({
                            center: intersection[1].point,
                            radius: rivers[i].r*square.width/1.2
                        })  
                        for(var l = 0; l<rivers[i].surroundedFlaps.length; l++){
                            //iterating through all surrounded flaps to see if the intersection is internal
                            if(intersection1 && intersection[0].point.getDistance(new paper.Point(
                                rivers[i].surroundedFlaps[l].x*square.width/1.2,
                                rivers[i].surroundedFlaps[l].y *square.width/1.2 *-1 + square.height/1.2)
                                ) <
                                findTreeDistance(rivers[i].surroundedFlaps[l],rivers[i].outerNode)*square.width/1.2 + 0.000001
                            ){
                                intersection1 = false;
                            }
                            if(intersection2 && intersection[1].point.getDistance(new paper.Point(
                                rivers[i].surroundedFlaps[l].x*square.width/1.2,
                                rivers[i].surroundedFlaps[l].y *square.width/1.2 *-1 + square.height/1.2)
                                ) <
                                findTreeDistance(rivers[i].surroundedFlaps[l],rivers[i].outerNode)*square.width/1.2 + 0.000001
                            ){
                                intersection2 = false;
                            }
                        }
                        //////////
                        if(intersection1||intersection2){
                            var subtraction1 = new paper.Path()
                            subtraction1.add(
                                intersection[0].point,
                                new paper.Point(
                                    rivers[i].surroundedFlaps[j].x*square.width/1.2,
                                    rivers[i].surroundedFlaps[j].y *square.width/1.2 *-1 + square.height/1.2),
                                //intersection[1].point,
                                new paper.Point(
                                    rivers[i].surroundedFlaps[k].x*square.width/1.2,
                                    rivers[i].surroundedFlaps[k].y *square.width/1.2 *-1 + square.height/1.2))
                            
                            var subtraction2 = new paper.Path()
                            subtraction2.add(
                                //intersection[0].point,
                                new paper.Point(
                                    rivers[i].surroundedFlaps[j].x*square.width/1.2,
                                    rivers[i].surroundedFlaps[j].y *square.width/1.2 *-1 + square.height/1.2),
                                intersection[1].point,
                                new paper.Point(
                                    rivers[i].surroundedFlaps[k].x*square.width/1.2,
                                    rivers[i].surroundedFlaps[k].y *square.width/1.2 *-1 + square.height/1.2))  
                        }

                        //subtractions.push(subtraction)
                        if(intersection1){
                            intersections.push(chunk1.intersect(subtraction1))
                            subtractions.push(subtraction1)
                        }
                        if(intersection2){
                            intersections.push(chunk2.intersect(subtraction2))
                            subtractions.push(subtraction2)
                        }
                    }
                }
                rivers[i].outerPath = tempCircles[0];
                for(var j=1; j<rivers[i].surroundedFlaps.length; j++){ //for every surrounded flap, there is a tempCircle
                    rivers[i].outerPath = rivers[i].outerPath.unite(tempCircles[j]);
                }//merge all the circles of radius += river radius
                for(var j = 0; j<subtractions.length; j++){
                    rivers[i].outerPath = rivers[i].outerPath.subtract(subtractions[j])
                }//remove all the internal quadrilaterals
                for(var j=0; j<intersections.length; j++){
                    rivers[i].outerPath = rivers[i].outerPath.unite(intersections[j])
                }
                try{
                    rivers[i].outerPath.fillColor = "cyan"
                    rivers[i].outerPath.strokeColor = "black"
                }catch{
                    0
                }
                
            }
        }
        calculateRivers()
        function drawCircles(){
            for (var i=0;i<flaps.length;i++){
                circle = new paper.Path.Circle(new paper.Point(
                    flaps[i].x *square.width/1.2,
                    flaps[i].y *square.width/1.2 *-1 + square.height/1.2
                    ), 
                    flaps[i].r*square.width/1.2);
                circle.strokeColor = "black";
                circle.fillColor = "#C5FBA8"
                circle.strokeWidth = 1;
                circles.push(circle);
            }
        }
        drawCircles(); //should also draw the centers of the circles
        function drawPaths(){
            for (var i=0;i<paths.length;i++){
                paths[i].check(paths[i].node1,paths[i].node2);
                if (paths[i].isActive){
                    path = new paper.Path.Line(
                    new paper.Point(
                            paths[i].node1.x *square.width/1.2,
                            paths[i].node1.y *square.width/1.2 *-1 + square.height/1.2),
                    new paper.Point(
                            paths[i].node2.x *square.width/1.2,
                            paths[i].node2.y *square.width/1.2 *-1 + square.height/1.2));
                    path.strokeColor = 'lime';
                    lines.push(path);
                } else if (paths[i].isInvalid){
                    path = new paper.Path.Line(
                    new paper.Point(
                            paths[i].node1.x *square.width/1.2,
                            paths[i].node1.y *square.width/1.2 *-1 + square.height/1.2),
                    new paper.Point(
                            paths[i].node2.x *square.width/1.2,
                            paths[i].node2.y *square.width/1.2 *-1 + square.height/1.2));
                    path.strokeColor = 'red';
                    lines.push(path);
                }
            }
        }
        drawPaths();
        
        //---------------main---------------
        paper.view.onFrame = function(event){
            /*for (var i=0; i<circles.length;i++){
                circles[i].remove();
            } */
            circles = [];
            lines = []; 
            paper.project.clear();
            calculateRivers();
            drawCircles();
            border.remove()
            drawBorder();
            drawPaths();

        }
        paper.view.draw();

    </script>
    <noscript>Please enable javascript to use this app.</noscript>
    <p>Import your .tmd5 (treemaker) file here:</p>
    <input type="file" id="inputfile" name = "inputfile">
    <pre id="output"></pre>
    <script>
        fileRead();
    </script>
    <button type = button onclick="extract()">Upload</button>  
    <p>This tool was created by Brandon Wong</p>
    <a href="https://github.com/theplantpsychologist/circle-jig"> Github repository</a>  
</body>
</html>